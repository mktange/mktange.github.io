<!doctype html><html lang="en"><head><title data-react-helmet="true">Tip: Proper handling of Plugin InputParameters</title><meta charset="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" name="generator" content="Phenomic 0.20.3"/><meta data-react-helmet="true" property="og:site_name" content="mktange-site"/><meta data-react-helmet="true" name="twitter:site" content="@mktangeDK"/><meta data-react-helmet="true" name="google-site-verification" content="Lo0KAD1VOmLeYX3xxa46H1Sxg9ds4xFcCZzkKtFy8ow"/><meta data-react-helmet="true" name="msapplication-TileColor" content="#ffffff"/><meta data-react-helmet="true" name="msapplication-TileImage" content="/icons/ms-icon-144x144.png"/><meta data-react-helmet="true" name="theme-color" content="#ffffff"/><meta data-react-helmet="true" name="viewport" content="width=device-width, initial-scale=1"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="Tip: Proper handling of Plugin InputParameters"/><meta data-react-helmet="true" property="og:url" content="http://mktange.com/posts/tip-plugin-inputparameters/"/><meta data-react-helmet="true" property="og:image" content="http://mktange.com/posts/tip-plugin-inputparameters/plugin-inputparameters.png"/><meta data-react-helmet="true" property="og:description" content="Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific magic strings, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach.  In my…"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" name="twitter:title" content="Tip: Proper handling of Plugin InputParameters"/><meta data-react-helmet="true" name="twitter:creator" content="@mktangeDK"/><meta data-react-helmet="true" name="twitter:description" content="Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific magic strings, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach.  In my…"/><meta data-react-helmet="true" name="twitter:image" content="http://mktange.com/posts/tip-plugin-inputparameters/plugin-inputparameters.png"/><meta data-react-helmet="true" name="description" content="Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific magic strings, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach.  In my…"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="57x57" href="/icons/apple-icon-57x57.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="60x60" href="/icons/apple-icon-60x60.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="72x72" href="/icons/apple-icon-72x72.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="76x76" href="/icons/apple-icon-76x76.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="114x114" href="/icons/apple-icon-114x114.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="120x120" href="/icons/apple-icon-120x120.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="144x144" href="/icons/apple-icon-144x144.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="152x152" href="/icons/apple-icon-152x152.png"/><link data-react-helmet="true" rel="apple-touch-icon" sizes="180x180" href="/icons/apple-icon-180x180.png"/><link data-react-helmet="true" rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png"/><link data-react-helmet="true" rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png"/><link data-react-helmet="true" rel="icon" type="image/png" sizes="96x96" href="/icons/favicon-96x96.png"/><link data-react-helmet="true" rel="icon" type="image/png" sizes="192x192" href="/icons/android-icon-192x192.png"/><link data-react-helmet="true" rel="icon" type="image/x-icon" href="/icons/favicon.ico"/><link data-react-helmet="true" rel="manifest" href="/icons/manifest.json"/><link rel="stylesheet" href="/phenomic.browser.8e61772f05fad15b9357.css"/><script data-react-helmet="true" src="https://cdn.polyfill.io/v2/polyfill.min.js?features=es6&amp;flags=gated"></script><script data-react-helmet="true" src="https://use.fontawesome.com/786ef9cc7a.js"></script></head><body><div id="phenomic"><div data-reactroot="" data-reactid="1" data-react-checksum="-1027431561"><div class="_2ip0s lightTheme" data-reactid="2"><div class="_2QrX5" style="top:170px;" data-reactid="3"><i class="fa fa-lightbulb-o fa-lg yFQWG" data-reactid="4"></i></div><div hidden="" data-reactid="5"><!-- react-empty: 6 --><!-- react-empty: 7 --><style data-reactid="8">@-ms-viewport { width: device-width; }</style></div><header class="CWa0d" data-reactid="9"><h1 class="_16HrB" data-reactid="10"><a class="_1fbR4" href="/" data-reactid="11">tange</a></h1><div class="_1NJ0O" data-reactid="12">Thoughts, types, tools, tips and tricks.</div><nav class="_2-vwL" data-reactid="13"><a href="mailto:mktange@gmail.com" class="F205O ZwV9j" data-reactid="14"><i class="fa fa-envelope" data-reactid="15"></i></a><a href="https://twitter.com/mktangeDK" target="_blank" class="F205O GjVId" data-reactid="16"><i class="fa fa-twitter fa-lg" data-reactid="17"></i></a><a href="https://github.com/mktange" target="_blank" class="F205O _2LiVa" data-reactid="18"><i class="fa fa-github fa-lg" data-reactid="19"></i></a><a href="https://www.linkedin.com/in/mktange" target="_blank" class="F205O _3I8bS" data-reactid="20"><i class="fa fa-linkedin" data-reactid="21"></i></a></nav><nav class="G3mQ7" data-reactid="22"><a class="MCrUZ _3uCxe" href="/feed.xml" data-reactid="23"><i class="fa fa-rss" data-reactid="24"></i><!-- react-text: 25 -->  Subscribe<!-- /react-text --></a></nav></header><div class="_1eMpg" data-reactid="26"><div class="_3Sbjc" data-reactid="27"><!-- react-empty: 28 --><h1 class="_1pYAy" data-reactid="29">Tip: Proper handling of Plugin InputParameters</h1><h2 class="_1Pvuo" data-reactid="30">The type-safe approach with intellisense</h2><div class="_2QPU1 _18pXI" data-reactid="31"><div data-reactid="32"><header class="_1Z9hw" data-reactid="33"><time data-reactid="34">Fri Mar 10 2017</time></header></div><div class="Uxkml" data-reactid="35"><div class="phenomic-BodyContainer" data-reactid="36"><p>Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific <em>magic strings</em>, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach. </p>
<p>In my quest to eliminate all uses of <em>magic strings</em> and <em>magic numbers</em> from my code, I have found a quite simple and neat solution to help with this issue, which I have not seen anyone else use so far.</p>
<h1 id="the-standard-approach"><a href="#the-standard-approach" class="phenomic-HeadingAnchor">#</a>The standard approach</h1>
<p>The most commonly-used method is to do as shown in the <a href="https://msdn.microsoft.com/en-us/library/gg309673.aspx#Anchor_4">MSDN docs</a>:</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">if</span> (context.InputParameters.Contains(<span class="hljs-string">"Target"</span>) &#x26;&#x26;
    context.InputParameters[<span class="hljs-string">"Target"</span>] <span class="hljs-keyword">is</span> Entity)
{
    <span class="hljs-comment">// Obtain the target entity from the input parameters.</span>
    Entity entity = (Entity)context.InputParameters[<span class="hljs-string">"Target"</span>];
}</code></pre>
<div class="caption">
  Example of getting <code>"Target"</code> parameter when the operation is <b>Create</b>.
</div>
<p>In order to retrieve the target entity safely from the InputParameters collection, we have to go through quite a few checks and use the magic string <code>"Target"</code> a few times. The type of the retrieved value is also checked to be an <code>Entity</code>, before casting the value to that type.</p>
<p>Now during a <strong>Delete</strong>-operation, there is also a <code>"Target"</code> in the InputParameters collection. This time, however, it has the type <code>EntityReference</code>:</p>
<pre><code class="hljs language-csharp"><span class="hljs-keyword">if</span> (context.InputParameters.Contains(<span class="hljs-string">"Target"</span>) &#x26;&#x26; 
    context.InputParameters[<span class="hljs-string">"Target"</span>] <span class="hljs-keyword">is</span> EntityReference)
{
    <span class="hljs-comment">// Obtain the target entity reference from the input parameters.</span>
    EntityReference entity = (EntityReference)context.InputParameters[<span class="hljs-string">"Target"</span>];
}</code></pre>
<div class="caption">
  Example of getting <code>"Target"</code> parameter when the operation is <b>Delete</b>.
</div>
<p>Not only do you need to know the magic strings necessary to get any information from the InputParameters collection (in this case <code>"Target"</code>), but you also need to know the output type.
The above cases even show that the same key can even have different types depending on the event-operation — which can lead to great confusion and non-working code the first time you encounter it as a developer.</p>
<p>One can quite quickly learn which parameters and types are present in the most basic operations (CRUD).
But when it comes to operations that you are not familiar, you have to look up the necessary magic strings and types online, and then use them correctly on the InputParameters collection. </p>
<p>For example, can you tell me which parameters (along with their types) are available during a <strong>WinOpportunity</strong>-operation? Would you have to check online to figure it out?</p>
<h1 id="the-type-safe-approach"><a href="#the-type-safe-approach" class="phenomic-HeadingAnchor">#</a>The type-safe approach</h1>
<p>This approach removes the need for any magic strings, automatically provides the type of each retrieved value, and even provides intellisense when retrieving the information available in the InputParameters collection.</p>
<p>And best of all, it is actually very simple. You just create a request of the matching type and pass in the parameters:</p>
<pre><code class="hljs language-csharp"><span class="hljs-comment">/* If the operation is Create */</span>
<span class="hljs-keyword">var</span> createReq = <span class="hljs-keyword">new</span> CreateRequest() { Parameters = context.InputParameters };
createReq.Target; <span class="hljs-comment">// Has type Entity</span></code></pre>
<pre><code class="hljs language-csharp"><span class="hljs-comment">/* If the operation is Delete */</span>
<span class="hljs-keyword">var</span> deleteReq = <span class="hljs-keyword">new</span> DeleteRequest() { Parameters = context.InputParameters };
deleteReq.Target; <span class="hljs-comment">// Has type EntityReference</span></code></pre>
<pre><code class="hljs language-csharp"><span class="hljs-comment">/* If the operation is WinOpportunity */</span>
<span class="hljs-keyword">var</span> winOppReq = <span class="hljs-keyword">new</span> WinOpportunityRequest() { Parameters = context.InputParameters };
winOppReq.OpportunityClose; <span class="hljs-comment">// Has type Entity (OpportunityClose)</span>
winOppReq.Status; <span class="hljs-comment">// Has type OptionSetValue</span></code></pre>
<div class="caption">
  Examples of using the alternative approach to handle InputParameters from a plugin execution context.
</div>
<p>All standard SDK requests are found in either <code>Microsoft.Xrm.Sdk.Messages</code> or <code>Microsoft.Crm.Sdk.Messages</code>, so be sure to include those with a <code>using</code>-statement.</p>
<p>Note that some requests can have "hidden" optional parameters, which are not defined as actual properties on the request. For example, <code>"SolutionUniqueName"</code> is a valid parameter for Create (<a href="https://msdn.microsoft.com/en-us/library/gg328075.aspx#bkmk_optional_params">and a few others</a>), but is not a property on the <code>CreateRequest</code> class. Unfortunately, these still have to be accessed using the standard approach with magic strings and type-casting.</p>
<p>This approach makes it much easier and simpler to safely handle InputParameters in plugin logic, and you (almost) never have to look up parameters for InputParameters again.</p>
</div></div><div data-reactid="37"><hr data-reactid="38"/><div data-reactid="39"><div id="disqus_thread" data-reactid="40"></div></div></div></div></div></div><footer class="_1Ustb" data-reactid="41"><p data-reactid="42"><a href="https://phenomic.io" class="_21LuU" data-reactid="43"><!-- react-text: 44 -->Website generated with <!-- /react-text --><span class="MMp-P" data-reactid="45">&lt;Phenomic /&gt;</span></a></p></footer></div></div></div><script>window.__COLLECTION__ = [{"layout":"PageError","comments":true,"route":"404.html","description":"","__filename":"404.md","__url":"/404.html","__resourceUrl":"/404.html","__dataUrl":"/404.html.7f6093458561a2a9bb2178ef2cba0f0f.json"},{"layout":"Homepage","comments":true,"title":"Welcome","metaTitle":"mktange's blog","description":"My name is Martin Kasban Tange.  I'm a Software Engineer with a drive to help increase code quality and productivity through the use of the newest languages, technologies and tools. I currently work at Palantir as a Forward Deployed Software Engineer based in Copenhagen, Denmark.","__filename":"index.md","__url":"/","__resourceUrl":"/index.html","__dataUrl":"/index.html.0504f19b01825647b5f24747af5e593d.json"},{"layout":"Post","comments":true,"title":"Tip: Proper handling of Plugin InputParameters","subtitle":"The type-safe approach with intellisense","date":"2017-03-10T00:00:00.000Z","tags":["Tip","MsDynCRM","MsDyn365","Plugin"],"image":"plugin-inputparameters.png","description":"Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific magic strings, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach.  In my…","__filename":"posts/tip-plugin-inputparameters/index.md","__url":"/posts/tip-plugin-inputparameters/","__resourceUrl":"/posts/tip-plugin-inputparameters/index.html","__dataUrl":"/posts/tip-plugin-inputparameters/index.html.653bb7be7845c305ed5c78e0689f7d59.json"},{"layout":"Post","comments":true,"title":"TypeScript and Dynamics 365/CRM","subtitle":"Client-side coding done right","date":"2017-02-26T00:00:00.000Z","tags":["TypeScript","MsDynCRM","MsDyn365","XrmDefinitelyTyped"],"description":"Coding and maintaining JavaScript for Dynamics 365/CRM can be quite a hassle if you don’t have a way to manage it properly.  Besides knowing how the client-side API works, it also relies on a lot of precise strings to accomplish anything meaningful in regard to the way the specific CRM system is set up. In this blog…","__filename":"posts/typescript-and-d365-crm/index.md","__url":"/posts/typescript-and-d365-crm/","__resourceUrl":"/posts/typescript-and-d365-crm/index.html","__dataUrl":"/posts/typescript-and-d365-crm/index.html.47f0af00c0e3b1485fff7384893ebbb0.json"}];window.__INITIAL_STATE__ = {"pages":{"/posts/tip-plugin-inputparameters/":{"head":{"layout":"Post","comments":true,"title":"Tip: Proper handling of Plugin InputParameters","subtitle":"The type-safe approach with intellisense","date":"2017-03-10T00:00:00.000Z","tags":["Tip","MsDynCRM","MsDyn365","Plugin"],"image":"plugin-inputparameters.png","description":"Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific magic strings, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach.  In my…"},"body":"<p>Retrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific <em>magic strings</em>, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach. </p>\n<p>In my quest to eliminate all uses of <em>magic strings</em> and <em>magic numbers</em> from my code, I have found a quite simple and neat solution to help with this issue, which I have not seen anyone else use so far.</p>\n<h1 id=\"the-standard-approach\"><a href=\"#the-standard-approach\" class=\"phenomic-HeadingAnchor\">#</a>The standard approach</h1>\n<p>The most commonly-used method is to do as shown in the <a href=\"https://msdn.microsoft.com/en-us/library/gg309673.aspx#Anchor_4\">MSDN docs</a>:</p>\n<pre><code class=\"hljs language-csharp\"><span class=\"hljs-keyword\">if</span> (context.InputParameters.Contains(<span class=\"hljs-string\">\"Target\"</span>) &#x26;&#x26;\n    context.InputParameters[<span class=\"hljs-string\">\"Target\"</span>] <span class=\"hljs-keyword\">is</span> Entity)\n{\n    <span class=\"hljs-comment\">// Obtain the target entity from the input parameters.</span>\n    Entity entity = (Entity)context.InputParameters[<span class=\"hljs-string\">\"Target\"</span>];\n}</code></pre>\n<div class=\"caption\">\n  Example of getting <code>\"Target\"</code> parameter when the operation is <b>Create</b>.\n</div>\n<p>In order to retrieve the target entity safely from the InputParameters collection, we have to go through quite a few checks and use the magic string <code>\"Target\"</code> a few times. The type of the retrieved value is also checked to be an <code>Entity</code>, before casting the value to that type.</p>\n<p>Now during a <strong>Delete</strong>-operation, there is also a <code>\"Target\"</code> in the InputParameters collection. This time, however, it has the type <code>EntityReference</code>:</p>\n<pre><code class=\"hljs language-csharp\"><span class=\"hljs-keyword\">if</span> (context.InputParameters.Contains(<span class=\"hljs-string\">\"Target\"</span>) &#x26;&#x26; \n    context.InputParameters[<span class=\"hljs-string\">\"Target\"</span>] <span class=\"hljs-keyword\">is</span> EntityReference)\n{\n    <span class=\"hljs-comment\">// Obtain the target entity reference from the input parameters.</span>\n    EntityReference entity = (EntityReference)context.InputParameters[<span class=\"hljs-string\">\"Target\"</span>];\n}</code></pre>\n<div class=\"caption\">\n  Example of getting <code>\"Target\"</code> parameter when the operation is <b>Delete</b>.\n</div>\n<p>Not only do you need to know the magic strings necessary to get any information from the InputParameters collection (in this case <code>\"Target\"</code>), but you also need to know the output type.\nThe above cases even show that the same key can even have different types depending on the event-operation — which can lead to great confusion and non-working code the first time you encounter it as a developer.</p>\n<p>One can quite quickly learn which parameters and types are present in the most basic operations (CRUD).\nBut when it comes to operations that you are not familiar, you have to look up the necessary magic strings and types online, and then use them correctly on the InputParameters collection. </p>\n<p>For example, can you tell me which parameters (along with their types) are available during a <strong>WinOpportunity</strong>-operation? Would you have to check online to figure it out?</p>\n<h1 id=\"the-type-safe-approach\"><a href=\"#the-type-safe-approach\" class=\"phenomic-HeadingAnchor\">#</a>The type-safe approach</h1>\n<p>This approach removes the need for any magic strings, automatically provides the type of each retrieved value, and even provides intellisense when retrieving the information available in the InputParameters collection.</p>\n<p>And best of all, it is actually very simple. You just create a request of the matching type and pass in the parameters:</p>\n<pre><code class=\"hljs language-csharp\"><span class=\"hljs-comment\">/* If the operation is Create */</span>\n<span class=\"hljs-keyword\">var</span> createReq = <span class=\"hljs-keyword\">new</span> CreateRequest() { Parameters = context.InputParameters };\ncreateReq.Target; <span class=\"hljs-comment\">// Has type Entity</span></code></pre>\n<pre><code class=\"hljs language-csharp\"><span class=\"hljs-comment\">/* If the operation is Delete */</span>\n<span class=\"hljs-keyword\">var</span> deleteReq = <span class=\"hljs-keyword\">new</span> DeleteRequest() { Parameters = context.InputParameters };\ndeleteReq.Target; <span class=\"hljs-comment\">// Has type EntityReference</span></code></pre>\n<pre><code class=\"hljs language-csharp\"><span class=\"hljs-comment\">/* If the operation is WinOpportunity */</span>\n<span class=\"hljs-keyword\">var</span> winOppReq = <span class=\"hljs-keyword\">new</span> WinOpportunityRequest() { Parameters = context.InputParameters };\nwinOppReq.OpportunityClose; <span class=\"hljs-comment\">// Has type Entity (OpportunityClose)</span>\nwinOppReq.Status; <span class=\"hljs-comment\">// Has type OptionSetValue</span></code></pre>\n<div class=\"caption\">\n  Examples of using the alternative approach to handle InputParameters from a plugin execution context.\n</div>\n<p>All standard SDK requests are found in either <code>Microsoft.Xrm.Sdk.Messages</code> or <code>Microsoft.Crm.Sdk.Messages</code>, so be sure to include those with a <code>using</code>-statement.</p>\n<p>Note that some requests can have \"hidden\" optional parameters, which are not defined as actual properties on the request. For example, <code>\"SolutionUniqueName\"</code> is a valid parameter for Create (<a href=\"https://msdn.microsoft.com/en-us/library/gg328075.aspx#bkmk_optional_params\">and a few others</a>), but is not a property on the <code>CreateRequest</code> class. Unfortunately, these still have to be accessed using the standard approach with magic strings and type-casting.</p>\n<p>This approach makes it much easier and simpler to safely handle InputParameters in plugin logic, and you (almost) never have to look up parameters for InputParameters again.</p>\n","rawBody":"\nRetrieving information from the InputParameters collection from a plugin execution context can be a quite cumbersome task. The standard approach requires the need to know very specific *magic strings*, and casting of variables to a specific type. This is, in my opinion, not a very good or maintainable approach. \n\nIn my quest to eliminate all uses of *magic strings* and *magic numbers* from my code, I have found a quite simple and neat solution to help with this issue, which I have not seen anyone else use so far.\n\n# The standard approach\n\nThe most commonly-used method is to do as shown in the [MSDN docs](https://msdn.microsoft.com/en-us/library/gg309673.aspx#Anchor_4):\n\n```csharp\nif (context.InputParameters.Contains(\"Target\") &&\n    context.InputParameters[\"Target\"] is Entity)\n{\n    // Obtain the target entity from the input parameters.\n    Entity entity = (Entity)context.InputParameters[\"Target\"];\n}\n```\n<div class=\"caption\">\n  Example of getting <code>\"Target\"</code> parameter when the operation is <b>Create</b>.\n</div>\n\nIn order to retrieve the target entity safely from the InputParameters collection, we have to go through quite a few checks and use the magic string `\"Target\"` a few times. The type of the retrieved value is also checked to be an `Entity`, before casting the value to that type.\n\nNow during a **Delete**-operation, there is also a `\"Target\"` in the InputParameters collection. This time, however, it has the type `EntityReference`:\n\n```csharp\nif (context.InputParameters.Contains(\"Target\") && \n    context.InputParameters[\"Target\"] is EntityReference)\n{\n    // Obtain the target entity reference from the input parameters.\n    EntityReference entity = (EntityReference)context.InputParameters[\"Target\"];\n}\n```\n<div class=\"caption\">\n  Example of getting <code>\"Target\"</code> parameter when the operation is <b>Delete</b>.\n</div>\n\nNot only do you need to know the magic strings necessary to get any information from the InputParameters collection (in this case `\"Target\"`), but you also need to know the output type.\nThe above cases even show that the same key can even have different types depending on the event-operation — which can lead to great confusion and non-working code the first time you encounter it as a developer.\n\nOne can quite quickly learn which parameters and types are present in the most basic operations (CRUD). \nBut when it comes to operations that you are not familiar, you have to look up the necessary magic strings and types online, and then use them correctly on the InputParameters collection. \n\nFor example, can you tell me which parameters (along with their types) are available during a **WinOpportunity**-operation? Would you have to check online to figure it out?\n\n\n\n\n# The type-safe approach\n\nThis approach removes the need for any magic strings, automatically provides the type of each retrieved value, and even provides intellisense when retrieving the information available in the InputParameters collection.\n\nAnd best of all, it is actually very simple. You just create a request of the matching type and pass in the parameters:\n\n```csharp\n/* If the operation is Create */\nvar createReq = new CreateRequest() { Parameters = context.InputParameters };\ncreateReq.Target; // Has type Entity\n```\n\n```csharp\n/* If the operation is Delete */\nvar deleteReq = new DeleteRequest() { Parameters = context.InputParameters };\ndeleteReq.Target; // Has type EntityReference\n```\n\n```csharp\n/* If the operation is WinOpportunity */\nvar winOppReq = new WinOpportunityRequest() { Parameters = context.InputParameters };\nwinOppReq.OpportunityClose; // Has type Entity (OpportunityClose)\nwinOppReq.Status; // Has type OptionSetValue\n```\n<div class=\"caption\">\n  Examples of using the alternative approach to handle InputParameters from a plugin execution context.\n</div>\n\nAll standard SDK requests are found in either `Microsoft.Xrm.Sdk.Messages` or `Microsoft.Crm.Sdk.Messages`, so be sure to include those with a `using`-statement.\n\nNote that some requests can have \"hidden\" optional parameters, which are not defined as actual properties on the request. For example, `\"SolutionUniqueName\"` is a valid parameter for Create ([and a few others](https://msdn.microsoft.com/en-us/library/gg328075.aspx#bkmk_optional_params)), but is not a property on the `CreateRequest` class. Unfortunately, these still have to be accessed using the standard approach with magic strings and type-casting.\n\nThis approach makes it much easier and simpler to safely handle InputParameters in plugin logic, and you (almost) never have to look up parameters for InputParameters again.\n","__filename":"posts/tip-plugin-inputparameters/index.md","__url":"/posts/tip-plugin-inputparameters/","__resourceUrl":"/posts/tip-plugin-inputparameters/index.html","__dataUrl":"/posts/tip-plugin-inputparameters/index.html.653bb7be7845c305ed5c78e0689f7d59.json","type":"Post"}}}</script><script src="/phenomic.browser.8e61772f05fad15b9357.js"></script></body></html>