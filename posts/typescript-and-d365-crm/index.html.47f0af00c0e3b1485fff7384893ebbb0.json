{"head":{"layout":"Post","comments":true,"title":"TypeScript and Dynamics 365/CRM","subtitle":"Client-side coding done right","date":"2017-02-26T00:00:00.000Z","tags":["TypeScript","MsDynCRM","MsDyn365","XrmDefinitelyTyped"],"description":"Coding and maintaining JavaScript for Dynamics 365/CRM can be quite a hassle if you don’t have a way to manage it properly.  Besides knowing how the client-side API works, it also relies on a lot of precise strings to accomplish anything meaningful in regard to the way the specific CRM system is set up. In this blog…"},"body":"<p>Coding and maintaining JavaScript for Dynamics 365/CRM can be quite a hassle if you don’t have a way to manage it properly.\nBesides knowing how the client-side API works, it also relies on a lot of precise strings to accomplish anything meaningful in regard to the way the specific CRM system is set up.</p>\n<p>In this blog post, I will be focusing on the issues a developer usually encounters when coding web resources that interact with a form and its logic,\nand how these issues can be alleviated using TypeScript — with the help of a tool called <a href=\"https://github.com/delegateas/XrmDefinitelyTyped/wiki\">XrmDefinitelyTyped</a>.</p>\n<h1 id=\"problems-with-plain-javascript\"><a href=\"#problems-with-plain-javascript\" class=\"phenomic-HeadingAnchor\">#</a>Problems with plain JavaScript</h1>\n<p>To add logic to a form in CRM, you use the client-side API called <code>Xrm.Page</code>. By using this you can interact with attribute values, add form logic on certain events,\nand manipulate how the form looks and acts. To access elements on a form, you need to use the logical name of the element you want in a matching getter function.</p>\n<pre><code class=\"hljs language-typescript\">Xrm.Page.getAttribute(<span class=\"hljs-string\">\"donotphone\"</span>).getValue();\nXrm.Page.getAttribute(<span class=\"hljs-string\">\"primarycontactid\"</span>).setValue([{ id: <span class=\"hljs-string\">\"GUID\"</span>, entityType: <span class=\"hljs-string\">\"contact\"</span> }]);\nXrm.Page.ui.tabs.get(<span class=\"hljs-string\">\"some_tab\"</span>).getDisplayState();</code></pre>\n<div class=\"caption\">Example usage of the form API.</div>\n<p>The problem here is that you need to know the <strong><em>exact</em></strong> string that is necessary when you want to access an attribute, a control, a tab, etc,\nin order to get that object and interact with it.\nAnd you better be sure that the element you are accessing in your code actually is present on the entity form — or users might experience this nasty error.</p>\n<figure>\n<img src=\"script-error.png\">\n<div class=\"caption\">Nasty error your users will experience when an invalid string is used.</div>\n</figure>\n<p>When dealing with attributes and controls, you also encounter the issue of needing to know what <strong><em>type</em></strong> the element holds.\nIs it a number attribute? A lookup field? An iframe control? JavaScript simply can't help you here.</p>\n<p>The main problem here is that CRM is dynamic, which means that the CRM JavaScript API also has to be.\nAnd this leads to the need for these precise strings — also commonly known as <em>magic strings</em> in programming.</p>\n<blockquote class=\"big-quote\">\nThe main problem here is that CRM is dynamic.\n</blockquote>\n<h1 id=\"enter-typescript\"><a href=\"#enter-typescript\" class=\"phenomic-HeadingAnchor\">#</a>Enter TypeScript</h1>\n<p><a href=\"http://www.typescriptlang.org/\">TypeScript</a> is a typed superset of JavaScript, which turns into regular JavaScript when it is run through the compiler.\nIt is written as JavaScript, but you are able to put types on top of it. And with these types, you are able to get type-checking and clever intellisense and autocomplete features in your IDE — which makes it more certain that what you code is actually correct code.</p>\n<p>Besides all the static type benefits of using TypeScript, you also get access to other nice and future features of JavaScript (ES6+), such as classes, arrow functions, template strings, destructuring and much more.\nTypeScript also allows you to structure your code in namespaces, and as such makes it easy to contain and expose functionality as necessary.</p>\n<h1 id=\"declaration-files-for-crm\"><a href=\"#declaration-files-for-crm\" class=\"phenomic-HeadingAnchor\">#</a>Declaration files for CRM</h1>\n<p>Declaration files are special TypeScript files, which describe how a JavaScript library/API can be used by declaring which types and functions are available, without specifying any of the actual library implementation.\nThe TypeScript compiler uses these files to infer types and check validity of your code for the described library.\nThe definitions in declaration files are only used by the compiler at compile-time, and is not included in the resulting code. This means that it <strong>does not</strong> slow down, or add to the outputted code JavaScript in any way.</p>\n<p>One way to use TypeScript with CRM is to use the <a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xrm\">declaration files found on DefinitelyTyped</a>.</p>\n<p>The problem with using these declaration files, however, is that they are <strong><em>static</em></strong>.\nThey are generic to the CRM API and not tailored to a specific CRM configuration, and thus can not help with the main pains/issues — like the <em>magic strings</em> and infering the types for each field.</p>\n<h1 id=\"dynamic-declaration-files-to-the-rescue\"><a href=\"#dynamic-declaration-files-to-the-rescue\" class=\"phenomic-HeadingAnchor\">#</a>Dynamic declaration files to the rescue</h1>\n<p>So we can establish that since CRM is dynamic, the declaration files should be as well.</p>\n<p>When I started working on client-side code in CRM about two years ago, I took note of this issue, and immediately started looking for a solution.\nAnd since no solution existed which resolved this issue, I decided to build a tool to alleviate this problem.</p>\n<p>The tool is called <a href=\"https://github.com/delegateas/XrmDefinitelyTyped/wiki\">XrmDefinitelyTyped (XDT)</a> and was released to the public in April 2015.\nIt has since then been <a href=\"http://delegateas.github.io/Delegate.XrmDefinitelyTyped/release-notes.html\">expanded with lots of new features and functionality</a>.\nIt is open-source and can be found on <a href=\"https://github.com/delegateas/XrmDefinitelyTyped\">GitHub</a>, if anyone wants to take a look at the code and chip in.</p>\n<blockquote class=\"quote\">\nIt is the TypeScript equivalent of <a target=\"_blank\" href=\"https://msdn.microsoft.com/en-us/library/gg327844.aspx\">CrmSvcUtil</a>, but instead of generating early-bound .NET classes for server-side code, it generates TypeScript interfaces for all your client-side coding.\n</blockquote>\n<p>When the tool is run, a base declaration file is created which describes the static interface for CRM — very similar to the static one found on DefinitelyTyped.\nBut with XDT, declaration files are also made specifically for each form, which describes exactly how that form can be interacted with.\nThis means that the TypeScript compiler can know precisely which fields, sections, and tabs are available on it, as well as the necessary magic strings needed to perform meaningful operations.</p>\n<pre><code class=\"hljs language-typescript\"><span class=\"hljs-keyword\">interface</span> Contact <span class=\"hljs-keyword\">extends</span> Xrm.PageBase&#x3C;Contact.Attributes,Contact.Tabs,Contact.Controls> {\n  getAttribute(attributeName: <span class=\"hljs-string\">\"fullname\"</span>): Xrm.Attribute&#x3C;<span class=\"hljs-built_in\">string</span>>;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"jobtitle\"</span>): Xrm.Attribute&#x3C;<span class=\"hljs-built_in\">string</span>>;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"parentcustomerid\"</span>): Xrm.LookupAttribute;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"emailaddress1\"</span>): Xrm.Attribute&#x3C;<span class=\"hljs-built_in\">string</span>>;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"telephone1\"</span>): Xrm.Attribute&#x3C;<span class=\"hljs-built_in\">string</span>>;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"address1_composite\"</span>): Xrm.Attribute&#x3C;<span class=\"hljs-built_in\">string</span>>;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"gendercode\"</span>): Xrm.OptionSetAttribute&#x3C;contact_gendercode>;\n  getAttribute(attributeName: <span class=\"hljs-string\">\"familystatuscode\"</span>): Xrm.OptionSetAttribute&#x3C;contact_familystatuscode>;\n…</code></pre>\n<div class=\"caption\">\nSnippet from a generated declaration file which describes a contact form.\n</div>\n<p>Besides declarations for forms, it can also generate interfaces for entities to be used in API calls towards the database — both the old REST endpoint <strong><em>and the new Web API</em></strong>.</p>\n<h1 id=\"developer-efficiency\"><a href=\"#developer-efficiency\" class=\"phenomic-HeadingAnchor\">#</a>Developer efficiency</h1>\n<p>Having TypeScript along with the dynamic declaration files immensely improves the development experience when dealing with the JavaScript APIs of CRM.\nHaving the code <strong>checked for validity at compile-time</strong> (instead of at run-time — on the CRM form) helps you save a lot of time developing and maintaining code.\nYou can be certain that the code you have written is correct according to the API, without typos, and that all the magic strings are correctly typed and valid in the given context.</p>\n<p>Not only does it check that the string parameters are correct, but it can even autocomplete them for you!\nThe other major benefit is that the compiler also knows exactly what type of attribute/control/entity it should expect at all times.</p>\n<p>Besides the form logic declaration files, XDT also includes TypeScript libraries for making calls towards the database.\nThese makes it possible to create calls to the CRM database in a completely type-safe manner with a LINQ-like query syntax, instead of having to construct your own OData query strings.\nThis library is called <a href=\"https://github.com/delegateas/XrmDefinitelyTyped/wiki/XrmQuery-Web-API\">XrmQuery</a>, and it exists in two instances, one for each of the OData endpoints. The libraries work in tandem with declaration files generated by\nXDT specifically for that purpose. In a later blog post I will be addressing XrmQuery in more detail.</p>\n<figure>\n  <video width=\"100%\" controls=\"true\" muted=\"true\">\n    <source src=\"xdt-demo-x1_25.mp4\" type=\"video/mp4\">\n    Your browser does not support the video tag.\n  </video>\n  <figcaption>Demonstration of various TypeScript features with XrmDefinitelyTyped (2min)</figcaption>\n</figure>\n<h1 id=\"upgrade-your-code-nowno-excuses\"><a href=\"#upgrade-your-code-nowno-excuses\" class=\"phenomic-HeadingAnchor\">#</a>Upgrade your code now — no excuses</h1>\n<p>Using the <a href=\"https://github.com/delegateas/XrmDefinitelyTyped/wiki/Getting-started\">quick-start guide</a>, you can get your project set up with XDT in a few minutes.\nConverting your code to TypeScript is usually quite straightforward. Just change your files from <code>.js</code> to <code>.ts</code>, and then the compiler will tell you exactly what may be problematic with the current code, which makes it quick and easy to fix.</p>\n","rawBody":"\nCoding and maintaining JavaScript for Dynamics 365/CRM can be quite a hassle if you don’t have a way to manage it properly. \nBesides knowing how the client-side API works, it also relies on a lot of precise strings to accomplish anything meaningful in regard to the way the specific CRM system is set up.\n\nIn this blog post, I will be focusing on the issues a developer usually encounters when coding web resources that interact with a form and its logic, \nand how these issues can be alleviated using TypeScript — with the help of a tool called [XrmDefinitelyTyped](https://github.com/delegateas/XrmDefinitelyTyped/wiki).\n\n\n# Problems with plain JavaScript\n\nTo add logic to a form in CRM, you use the client-side API called `Xrm.Page`. By using this you can interact with attribute values, add form logic on certain events, \nand manipulate how the form looks and acts. To access elements on a form, you need to use the logical name of the element you want in a matching getter function.\n\n```typescript\nXrm.Page.getAttribute(\"donotphone\").getValue();\nXrm.Page.getAttribute(\"primarycontactid\").setValue([{ id: \"GUID\", entityType: \"contact\" }]);\nXrm.Page.ui.tabs.get(\"some_tab\").getDisplayState();\n```\n<div class=\"caption\">Example usage of the form API.</div>\n\n\nThe problem here is that you need to know the ***exact*** string that is necessary when you want to access an attribute, a control, a tab, etc, \nin order to get that object and interact with it. \nAnd you better be sure that the element you are accessing in your code actually is present on the entity form — or users might experience this nasty error.\n\n<figure>\n<img src=\"script-error.png\">\n<div class=\"caption\">Nasty error your users will experience when an invalid string is used.</div>\n</figure>\n\nWhen dealing with attributes and controls, you also encounter the issue of needing to know what ***type*** the element holds. \nIs it a number attribute? A lookup field? An iframe control? JavaScript simply can't help you here.\n\nThe main problem here is that CRM is dynamic, which means that the CRM JavaScript API also has to be. \nAnd this leads to the need for these precise strings — also commonly known as *magic strings* in programming.\n\n<blockquote class=\"big-quote\">\nThe main problem here is that CRM is dynamic.\n</blockquote>\n\n\n# Enter TypeScript\n\n[TypeScript](http://www.typescriptlang.org/) is a typed superset of JavaScript, which turns into regular JavaScript when it is run through the compiler. \nIt is written as JavaScript, but you are able to put types on top of it. And with these types, you are able to get type-checking and clever intellisense and autocomplete features in your IDE — which makes it more certain that what you code is actually correct code.\n\nBesides all the static type benefits of using TypeScript, you also get access to other nice and future features of JavaScript (ES6+), such as classes, arrow functions, template strings, destructuring and much more. \nTypeScript also allows you to structure your code in namespaces, and as such makes it easy to contain and expose functionality as necessary.\n\n\n# Declaration files for CRM\n\nDeclaration files are special TypeScript files, which describe how a JavaScript library/API can be used by declaring which types and functions are available, without specifying any of the actual library implementation. \nThe TypeScript compiler uses these files to infer types and check validity of your code for the described library. \nThe definitions in declaration files are only used by the compiler at compile-time, and is not included in the resulting code. This means that it **does not** slow down, or add to the outputted code JavaScript in any way.\n\nOne way to use TypeScript with CRM is to use the [declaration files found on DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/types/xrm).\n\nThe problem with using these declaration files, however, is that they are ***static***. \nThey are generic to the CRM API and not tailored to a specific CRM configuration, and thus can not help with the main pains/issues — like the *magic strings* and infering the types for each field.\n\n\n# Dynamic declaration files to the rescue\n\nSo we can establish that since CRM is dynamic, the declaration files should be as well.\n\nWhen I started working on client-side code in CRM about two years ago, I took note of this issue, and immediately started looking for a solution. \nAnd since no solution existed which resolved this issue, I decided to build a tool to alleviate this problem.\n\nThe tool is called [XrmDefinitelyTyped (XDT)](https://github.com/delegateas/XrmDefinitelyTyped/wiki) and was released to the public in April 2015. \nIt has since then been [expanded with lots of new features and functionality](http://delegateas.github.io/Delegate.XrmDefinitelyTyped/release-notes.html). \nIt is open-source and can be found on [GitHub](https://github.com/delegateas/XrmDefinitelyTyped), if anyone wants to take a look at the code and chip in.\n\n<blockquote class=\"quote\">\nIt is the TypeScript equivalent of <a target=\"_blank\" href=\"https://msdn.microsoft.com/en-us/library/gg327844.aspx\">CrmSvcUtil</a>, but instead of generating early-bound .NET classes for server-side code, it generates TypeScript interfaces for all your client-side coding.\n</blockquote>\n\nWhen the tool is run, a base declaration file is created which describes the static interface for CRM — very similar to the static one found on DefinitelyTyped. \nBut with XDT, declaration files are also made specifically for each form, which describes exactly how that form can be interacted with. \nThis means that the TypeScript compiler can know precisely which fields, sections, and tabs are available on it, as well as the necessary magic strings needed to perform meaningful operations.\n\n\n```typescript\ninterface Contact extends Xrm.PageBase<Contact.Attributes,Contact.Tabs,Contact.Controls> {\n  getAttribute(attributeName: \"fullname\"): Xrm.Attribute<string>;\n  getAttribute(attributeName: \"jobtitle\"): Xrm.Attribute<string>;\n  getAttribute(attributeName: \"parentcustomerid\"): Xrm.LookupAttribute;\n  getAttribute(attributeName: \"emailaddress1\"): Xrm.Attribute<string>;\n  getAttribute(attributeName: \"telephone1\"): Xrm.Attribute<string>;\n  getAttribute(attributeName: \"address1_composite\"): Xrm.Attribute<string>;\n  getAttribute(attributeName: \"gendercode\"): Xrm.OptionSetAttribute<contact_gendercode>;\n  getAttribute(attributeName: \"familystatuscode\"): Xrm.OptionSetAttribute<contact_familystatuscode>;\n…\n```\n<div class=\"caption\">\nSnippet from a generated declaration file which describes a contact form.\n</div>\n\nBesides declarations for forms, it can also generate interfaces for entities to be used in API calls towards the database — both the old REST endpoint ***and the new Web API***.\n\n\n# Developer efficiency\n\nHaving TypeScript along with the dynamic declaration files immensely improves the development experience when dealing with the JavaScript APIs of CRM. \nHaving the code **checked for validity at compile-time** (instead of at run-time — on the CRM form) helps you save a lot of time developing and maintaining code. \nYou can be certain that the code you have written is correct according to the API, without typos, and that all the magic strings are correctly typed and valid in the given context.\n\nNot only does it check that the string parameters are correct, but it can even autocomplete them for you! \nThe other major benefit is that the compiler also knows exactly what type of attribute/control/entity it should expect at all times.\n\nBesides the form logic declaration files, XDT also includes TypeScript libraries for making calls towards the database. \nThese makes it possible to create calls to the CRM database in a completely type-safe manner with a LINQ-like query syntax, instead of having to construct your own OData query strings. \nThis library is called [XrmQuery](https://github.com/delegateas/XrmDefinitelyTyped/wiki/XrmQuery-Web-API), and it exists in two instances, one for each of the OData endpoints. The libraries work in tandem with declaration files generated by \nXDT specifically for that purpose. In a later blog post I will be addressing XrmQuery in more detail.\n\n<figure>\n  <video width=\"100%\" controls=\"true\" muted=\"true\">\n    <source src=\"xdt-demo-x1_25.mp4\" type=\"video/mp4\">\n    Your browser does not support the video tag.\n  </video>\n  <figcaption>Demonstration of various TypeScript features with XrmDefinitelyTyped (2min)</figcaption>\n</figure>\n\n\n# Upgrade your code now — no excuses\n\nUsing the [quick-start guide](https://github.com/delegateas/XrmDefinitelyTyped/wiki/Getting-started), you can get your project set up with XDT in a few minutes. \nConverting your code to TypeScript is usually quite straightforward. Just change your files from `.js` to `.ts`, and then the compiler will tell you exactly what may be problematic with the current code, which makes it quick and easy to fix.","__filename":"posts/typescript-and-d365-crm/index.md","__url":"/posts/typescript-and-d365-crm/","__resourceUrl":"/posts/typescript-and-d365-crm/index.html","__dataUrl":"/posts/typescript-and-d365-crm/index.html.47f0af00c0e3b1485fff7384893ebbb0.json"}